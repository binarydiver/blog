(self.webpackChunk_N_E=self.webpackChunk_N_E||[]).push([[625],{8310:function(n,e,t){(window.__NEXT_P=window.__NEXT_P||[]).push(["/articles/2024/09/14/build_blog_with_nextjs_on_github",function(){return t(9905)}])},9905:function(n,e,t){"use strict";t.r(e),t.d(e,{__N_SSG:function(){return d},default:function(){return g},markdoc:function(){return u}});var o=t(5271),s=t(487),a=t(6798),r=t(8687);let i=new a.ZP.Tokenizer({allowComments:!0}).tokenize('---\ndocName: \'build_blog_with_nextjs_on_github\'\ntitle: Next.js로 GitHub Page에 블로그 개설하기\ndescription: Next.js로 정적 웹사이트를 추출하여 GitHub Page 위에서 운영할 수 있는 블로그를 개설한 과정에 대한 이야기이다.\nkeywords: [\'next.js\', \'blog\', \'markdoc\']\nwrittenAt: \'2024-09-15 09:00\'\nupdatedAt: \'2024-09-15 09:00\'\n---\n\n# Next.js로 GitHub Page에 블로그 개설하기\n\n나만의 보관소에 기록을 하고 있는 내용들을 공개적으로 공유하고, 다른 사람에게 전달할 때도 수월하게 하고 싶어 블로그를 개설하기로 했다.\n그래서 블로그를 운영하기 위한 여러 방법을 모색했다.<br>\n원하는 주요 기능은 다음과 같다.\n\n1. 글을 쉽게 이전 및 추출할 수 있도록 DB 통제권을 가져야 한다.\n2. 표준화된 포맷으로 글을 작성 및 추출할 수 있어 파싱이 수월해야 한다.\n3. 글에 코멘트를 올려 소통할 수 있어야 한다.\n4. 레이아웃과 테마를 최대한 커스텀할 수 있어야 한다.\n5. 국내/외 검색 엔진에 크롤링될 수 있어야 한다.\n\n1, 2번을 제외한다면 블로그를 운영하기 좋은 서비스들은 많이 존재한다.<br>\n특히 4번의 검색 엔진 노출의 경우 유명한 블로그 서비스에 글을 올리는 것이 백링크 측면에서 더 유리하다.<br>\n그러나 프로그래머일수록 1, 2번이 마음에 걸릴 수 있다.<br>\n결국 데이터베이스 통제권이 없다는 것은 내가 쓴 글의 소유권을 절반만 갖고 있다고 봐야 한다. 글을 완전히 소유하기 위해 별도의 기록소를 운영할 수 있지만 두번의 기록은 번거롭다.\n완벽에 가까운 해결책은 직접 웹사이트를 만들어서 서버를 구매해 올리는 것이다.\n하지만 우리는 이런 Zero to One이 얼마나 거추장스러운 일인지 잘 알고 있다.\n게다가 투자하는 모든 자원에 비해 결과가 목표를 넘어 자기만족에 그칠 가능성이 매우 높다.\n예측하기 어려운 미래에 대한 모든 시작은 변화에 능동적으로 대처할 수 있도록 규모가 작아야 좋다.\n그래서 추가적인 재화의 소모도 없고 오직 프로그래밍 능력만으로 1 ~ 5번을 모두 만족할 수 있는 방법으로 GitHub Page를 이용하기로 결정했다.\n과거에는 Jekyll를 이용해서 정적 사이트를 만들어 GitHub Page에 올리는 것이 많이 사용되던 방식이었다.\n하지만 리액트 바람이 불어온 뒤 격변의 시간이 지난 웹 시장에는 정적 웹사이트를 추출할 수 있는 라이브러리들이 훨씬 더 많아졌다.\n내가 현재 가장 익숙한 웹 사이트 제작 프레임워크는 Next.js 였고 이를 이용해서 제작하기로 했다.\n\nNext.js 14.2.9 기준에서 개발 과정은 다음과 같다.<br>\n\n다음 [CLI](https://nextjs.org/docs/pages/api-reference/cli/create-next-app)로 Next.js 프로젝트를 생성한다.<br>\n\n```bash\npnpm create next-app test-nextjs-blog --ts --tailwind --eslint --no-app --no-src-dir --import-alias "@/*" --use-pnpm\n```\n\n"styles/globals.css"의 내용을 비우고 "[Noto Sans KR](https://fonts.google.com/noto/specimen/Noto+Sans+KR?query=noto+sans+kr)"를 기본 폰트로 추가한다.\n\n```css\n@import url(\'https://fonts.googleapis.com/css2?family=Noto+Sans+KR:wght@100..900&display=swap\');\n\n@tailwind base;\n@tailwind components;\n@tailwind utilities;\n\n@layer base {\n  html {\n    @apply font-sans;\n  }\n}\n```\n\n"pages/\\_document.tsx" 를 다음과 같이 변경한다.<br>\n여기서 "favicon.ico" 앞에 "./"를 붙인 것에 주목해야 한다.<br>\n커스텀 도메인을 지정하지 않으면 배포 시 주소가 "...gihub.io/{repository_name}"가 된다.\n그냥 "/favicon.io" 를\n\n```tsx\nexport default function Document() {}\n```\n\n"\\_component" 폴더를 만들고 "header.tsx"를 생성한다.\n\n```tsx\ntype HeaderProps = {\n  title: string;\n};\n\nconst Header = (props: HeaderProps) => {\n  const { title } = props;\n\n  return (\n    <nav className="border-b p-4">\n      <div className="flex max-w-screen-lg m-auto">\n        <div className="flex-auto">\n          <Link className="no-underline" href={\'/\'}>\n            <h1 className="leading-normal m-0">{title}</h1>\n          </Link>\n        </div>\n        <div className="flex flex-1 gap-x-2 items-center justify-end">\n          // 라이트/다크 테마 전환을 위한 버튼\n          <button\n            type="button"\n            className="text-white bg-gray-300 hover:bg-gray-400 focus:ring-gray-500 focus:outline-none focus:ring-2 font-medium rounded-lg text-4xl px-1.5 pb-1 dark:bg-gray-100 dark:hover:dark:bg-gray-400 dark:focus:ring-gray-200"\n            onClick={() => toggleTheme()}\n          >\n            \uD83C\uDF13︎\n          </button>\n        </div>\n      </div>\n    </nav>\n  );\n};\n\nexport default Header;\n```\n\n```bash\npnpm add @markdoc/next.js @markdoc/markdoc\n```\n\n```bash\npnpm add fast-glob gray-matter\n```\n\n```bash\npnpm add -D rss @types/rss\n```\n\n```bash\npackage.json에 다음 스크립트를 추가한다.\n```\n\n```json\n{\n  /* ... */\n  "scripts": {\n    /* ... */\n    "predeploy": "pnpm run build && touch out/.nojekyll && echo \\"your-domain.com\\" > out/CNAME"\n    // ref. https://github.blog/news-insights/bypassing-jekyll-on-github-pages/\n  }\n}\n```\n\ncustom domain 연결 시 too many request 에러가 발생한다면, cloudflare 의 경우 dns proxy 를 끄거나 https full(strict)로 변경해야 한다.\n\nnext.config.mjs\n\n```\n// ref. https://nextjs.org/docs/app/api-reference/next-config-js/headers#options\n```\n\nref. https://alvinwanjala.com/blog/adding-security-headers-nextjs/\n\n검색 기능을 고려하고 있다.\n\nref. https://create-react-app.dev/docs/deployment/#notes-on-client-side-routing\n\nref. https://code.pieces.app/blog/building-blogs-markdoc-nextjs\nref. https://medium.com/@docploy/how-to-build-a-blog-using-next-js-and-markdoc-b4cfe8ed9dca\n\nref. https://nextjs.org/learn-pages-router/basics/dynamic-routes/render-markdown\n\nref. https://dev.to/promathieuthiry/creating-an-rss-feed-in-your-nextjs-project-20em\n'),c=a.ZP.parse(i,{slots:!1}),p=c.attributes.frontmatter?s.ZP.load(c.attributes.frontmatter):{},{components:l}=(0,r.J)({});var d=!0;let u={frontmatter:p};function g(n){let e=n.markdoc;return a.RZ.react(e.content,o,{components:{...l,...n.components}})}}},function(n){n.O(0,[217,285,888,774,179],function(){return n(n.s=8310)}),_N_E=n.O()}]);